# ğŸš€ æ–¹æ¡ˆ Aï¼šæ·±åº¦èåˆæ¶æ„ - å®Œæ•´å®æ–½æ–¹æ¡ˆ

**æ—¥æœŸ**: 2026-01-25  
**ç¯å¢ƒ**: fusion-experiment (å®‰å…¨å®éªŒç¯å¢ƒ)  
**ç›®æ ‡**: ä»£ç çº§æ·±åº¦é›†æˆï¼Œå®ç°çœŸæ­£çš„èåˆæ€§å¢å¼º

---

## ğŸ“‹ ç›®å½•

1. [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
2. [æ ¸å¿ƒè®¾è®¡åŸåˆ™](#æ ¸å¿ƒè®¾è®¡åŸåˆ™)
3. [ç³»ç»Ÿæ¶æ„å¯¹æ¯”](#ç³»ç»Ÿæ¶æ„å¯¹æ¯”)
4. [èåˆæ¶æ„è®¾è®¡](#èåˆæ¶æ„è®¾è®¡)
5. [è¯¦ç»†å®æ–½æ­¥éª¤](#è¯¦ç»†å®æ–½æ­¥éª¤)
6. [ä»£ç å®ç°](#ä»£ç å®ç°)
7. [é…ç½®å’Œéƒ¨ç½²](#é…ç½®å’Œéƒ¨ç½²)
8. [æµ‹è¯•éªŒè¯](#æµ‹è¯•éªŒè¯)
9. [æ—¶é—´è§„åˆ’](#æ—¶é—´è§„åˆ’)

---

## ğŸ¯ æ¶æ„æ¦‚è§ˆ

### èåˆåçš„ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        GalaxyClient                              â”‚
â”‚                    (å¾®è½¯çš„ï¼Œè½»åº¦æ‰©å±•)                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              TopologyAwareConstellationClient                    â”‚
â”‚                  (æ–°å¢ï¼Œæ‹“æ‰‘æ„ŸçŸ¥çš„å®¢æˆ·ç«¯)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  ConstellationClient (å¾®è½¯çš„åŸºç¡€åŠŸèƒ½)                    â”‚  â”‚
â”‚  â”‚  + TopologyManager (æ‹“æ‰‘ç®¡ç†)                            â”‚  â”‚
â”‚  â”‚  + TopologyRouter (æ‹“æ‰‘è·¯ç”±)                             â”‚  â”‚
â”‚  â”‚  + LoadBalancer (è´Ÿè½½å‡è¡¡)                               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  AIP Protocol   â”‚
                    â”‚   (ç»Ÿä¸€æ‰©å±•)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                    â”‚                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Core Layer     â”‚  â”‚ Cognitive Layer â”‚  â”‚ Perception     â”‚
â”‚ (16 nodes)     â”‚  â”‚ (46 nodes)      â”‚  â”‚ Layer          â”‚
â”‚                â”‚  â”‚                 â”‚  â”‚ (31 nodes)     â”‚
â”‚ Node_00        â”‚  â”‚ Node_16         â”‚  â”‚ Node_62        â”‚
â”‚ Node_04        â”‚  â”‚ Node_20         â”‚  â”‚ Node_70        â”‚
â”‚ ...            â”‚  â”‚ ...             â”‚  â”‚ ...            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’¡ æ ¸å¿ƒè®¾è®¡åŸåˆ™

### 1. æœ€å°ä¾µå…¥æ€§

**åŸåˆ™**: å°½é‡å°‘ä¿®æ”¹å¾®è½¯ UFO çš„æ ¸å¿ƒä»£ç 

**å®æ–½**:
- âœ… é€šè¿‡**ç»§æ‰¿**æ‰©å±• ConstellationClient
- âœ… é€šè¿‡**ç»„åˆ**æ·»åŠ æ‹“æ‰‘ç®¡ç†åŠŸèƒ½
- âœ… é€šè¿‡**é…ç½®**å¯ç”¨/ç¦ç”¨æ‹“æ‰‘åŠŸèƒ½
- âŒ ä¸ç›´æ¥ä¿®æ”¹å¾®è½¯çš„æ ¸å¿ƒç±»

### 2. åè®®ç»Ÿä¸€

**åŸåˆ™**: ç»Ÿä¸€å¾®è½¯ AIP å’Œä½ çš„ AIP v2.0

**å®æ–½**:
- æ‰©å±•å¾®è½¯ AIP æ¶ˆæ¯ï¼Œæ·»åŠ æ‹“æ‰‘å­—æ®µ
- ä¿æŒå‘åå…¼å®¹
- æ”¯æŒåè®®ç‰ˆæœ¬åå•†

### 3. æ‹“æ‰‘åŸç”ŸåŒ–

**åŸåˆ™**: è®©å¾®è½¯ Galaxy åŸç”Ÿç†è§£ä¸‰å±‚çƒä½“æ‹“æ‰‘

**å®æ–½**:
- æ‹“æ‰‘ä¿¡æ¯ä½œä¸ºè®¾å¤‡å…ƒæ•°æ®
- è·¯ç”±ç®—æ³•åŸºäºæ‹“æ‰‘
- è´Ÿè½½å‡è¡¡è€ƒè™‘æ‹“æ‰‘ç»“æ„

### 4. æ¸è¿›å¼èåˆ

**åŸåˆ™**: åˆ†é˜¶æ®µå®æ–½ï¼Œæ¯ä¸ªé˜¶æ®µéƒ½å¯ç‹¬ç«‹è¿è¡Œ

**å®æ–½**:
- é˜¶æ®µ 1: åŸºç¡€é€‚é…ï¼ˆ1-2 å‘¨ï¼‰
- é˜¶æ®µ 2: æ‹“æ‰‘é›†æˆï¼ˆ2-3 å‘¨ï¼‰
- é˜¶æ®µ 3: æ·±åº¦ä¼˜åŒ–ï¼ˆ3-4 å‘¨ï¼‰

---

## ğŸ“Š ç³»ç»Ÿæ¶æ„å¯¹æ¯”

### å¾®è½¯ UFOÂ³ Galaxy

```python
# æ¶æ„ç‰¹ç‚¹
- è½»é‡çº§ Device Agent
- åŠ¨æ€ DAG ç¼–æ’ (TaskConstellation)
- WebSocket + JSON-RPC
- è®¾å¤‡æ³¨å†Œ + å¿ƒè·³æœºåˆ¶
- è·¨è®¾å¤‡ä»»åŠ¡åˆ†å‘

# æ ¸å¿ƒç»„ä»¶
GalaxyClient
  â””â”€ ConstellationClient
      â”œâ”€ DeviceManager
      â”‚   â”œâ”€ DeviceRegistry
      â”‚   â”œâ”€ ConnectionManager
      â”‚   â””â”€ HeartbeatManager
      â””â”€ TaskQueueManager
```

### ä½ çš„ ufo-galaxy-unified

```python
# æ¶æ„ç‰¹ç‚¹
- é‡é‡çº§åŠŸèƒ½èŠ‚ç‚¹ (103 ä¸ª)
- ä¸‰å±‚çƒä½“æ‹“æ‰‘ (Core, Cognitive, Perception)
- AIP v2.0 å¤šåª’ä½“åè®®
- FastAPI + Redis
- åŸŸé©±åŠ¨è®¾è®¡ (vision, nlu, state_management, etc.)

# æ ¸å¿ƒç»„ä»¶
System Manager
  â””â”€ Galaxy Gateway
      â”œâ”€ Task Router (åŸºäºåŸŸ)
      â”œâ”€ Device Router (åŸºäºæ‹“æ‰‘)
      â”œâ”€ NLU Engine
      â””â”€ Cross-Device Coordinator
```

### å…³é”®å·®å¼‚

| ç»´åº¦ | å¾®è½¯ UFOÂ³ | ä½ çš„ç³»ç»Ÿ | èåˆç­–ç•¥ |
|------|-----------|----------|----------|
| **èŠ‚ç‚¹æ¨¡å‹** | è½»é‡çº§ Agent | é‡é‡çº§ Node | èŠ‚ç‚¹å®ç° AIP æ¥å£ |
| **æ‹“æ‰‘** | å¹³é¢ç»“æ„ | ä¸‰å±‚çƒä½“ | æ‰©å±• AIP æ”¯æŒæ‹“æ‰‘ |
| **åè®®** | WebSocket + JSON-RPC | AIP v2.0 å¤šåª’ä½“ | ç»Ÿä¸€ä¸ºæ‰©å±• AIP |
| **è·¯ç”±** | åŸºäºèƒ½åŠ› | åŸºäºåŸŸ+æ‹“æ‰‘ | æ‹“æ‰‘æ„ŸçŸ¥è·¯ç”± |
| **ç¼–æ’** | åŠ¨æ€ DAG | é™æ€æ‹“æ‰‘ | æ··åˆæ¨¡å¼ |

---

## ğŸ—ï¸ èåˆæ¶æ„è®¾è®¡

### 1. æ‰©å±• AIP åè®®

#### 1.1 æ‹“æ‰‘å…ƒæ•°æ®

```python
# åœ¨ microsoft-ufo/aip/messages.py ä¸­æ·»åŠ 

from typing import Tuple, List
from pydantic import BaseModel

@dataclass
class TopologyInfo(BaseModel):
    """æ‹“æ‰‘ä¿¡æ¯ - ä¸‰å±‚çƒä½“æ‹“æ‰‘"""
    
    # å±‚çº§ (Layer)
    layer: str  # "core", "cognitive", "perception"
    layer_index: int  # 0, 1, 2
    
    # åŸŸ (Domain)
    domain: str  # "vision", "nlu", "state_management", etc.
    
    # çƒé¢åæ ‡ (Spherical Coordinates)
    # ç”¨äºå¯è§†åŒ–å’Œè·¯å¾„ä¼˜åŒ–
    theta: float  # æè§’ [0, Ï€]
    phi: float    # æ–¹ä½è§’ [0, 2Ï€]
    radius: float  # åŠå¾„ (å±‚çº§å†³å®š)
    
    # æ‹“æ‰‘å…³ç³»
    neighbors: List[str]  # é‚»å±…èŠ‚ç‚¹ ID
    parent_nodes: List[str]  # çˆ¶èŠ‚ç‚¹ (ä¸Šå±‚)
    child_nodes: List[str]   # å­èŠ‚ç‚¹ (ä¸‹å±‚)
    
    # è·¯ç”±æƒé‡
    routing_weight: float = 1.0  # è·¯ç”±æƒé‡
    load_capacity: int = 100     # è´Ÿè½½å®¹é‡

@dataclass
class DeviceMetadataExtended(BaseModel):
    """æ‰©å±•çš„è®¾å¤‡å…ƒæ•°æ®"""
    
    # åŸæœ‰å­—æ®µ (å…¼å®¹å¾®è½¯)
    os: Optional[str] = None
    capabilities: List[str] = []
    
    # æ–°å¢æ‹“æ‰‘å­—æ®µ
    topology: Optional[TopologyInfo] = None
    
    # æ€§èƒ½æŒ‡æ ‡
    cpu_cores: int = 1
    memory_mb: int = 1024
    current_load: float = 0.0

# æ‰©å±• ClientMessage
class ClientMessage(BaseModel):
    # ... åŸæœ‰å­—æ®µ ...
    
    # æ–°å¢å­—æ®µ
    topology_metadata: Optional[TopologyInfo] = None
```

#### 1.2 æ‹“æ‰‘è·¯ç”±æ¶ˆæ¯

```python
@dataclass
class TopologyRoutingHint(BaseModel):
    """æ‹“æ‰‘è·¯ç”±æç¤º"""
    
    # é¦–é€‰å±‚çº§
    preferred_layer: Optional[str] = None
    
    # é¦–é€‰åŸŸ
    preferred_domain: Optional[str] = None
    
    # æºèŠ‚ç‚¹ (ç”¨äºè·¯å¾„ä¼˜åŒ–)
    source_node_id: Optional[str] = None
    
    # è·¯ç”±ç­–ç•¥
    routing_strategy: str = "shortest_path"  # "shortest_path", "load_balanced", "domain_affinity"
    
    # çº¦æŸæ¡ä»¶
    exclude_nodes: List[str] = []
    required_capabilities: List[str] = []

# æ‰©å±• ServerMessage
class ServerMessage(BaseModel):
    # ... åŸæœ‰å­—æ®µ ...
    
    # æ–°å¢å­—æ®µ
    routing_hint: Optional[TopologyRoutingHint] = None
    selected_node_path: Optional[List[str]] = None  # é€‰æ‹©çš„èŠ‚ç‚¹è·¯å¾„
```

---

### 2. æ‹“æ‰‘ç®¡ç†å™¨ (TopologyManager)

#### 2.1 æ ¸å¿ƒèŒè´£

```python
"""
TopologyManager - æ‹“æ‰‘ç®¡ç†å™¨

èŒè´£:
1. åŠ è½½å’Œç®¡ç†ä¸‰å±‚çƒä½“æ‹“æ‰‘
2. æä¾›æ‹“æ‰‘æŸ¥è¯¢æ¥å£
3. è®¡ç®—æœ€ä¼˜è·¯ç”±è·¯å¾„
4. è´Ÿè½½å‡è¡¡
5. æ‹“æ‰‘å¯è§†åŒ–
"""
```

#### 2.2 å®ç°

```python
# åˆ›å»º fusion-experiment/ufo-galaxy-unified/fusion/topology_manager.py

import json
import logging
import networkx as nx
from typing import Dict, List, Optional, Tuple, Set
from pathlib import Path
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class NodeInfo:
    """èŠ‚ç‚¹ä¿¡æ¯"""
    node_id: str
    node_name: str
    layer: str
    domain: str
    coordinates: Tuple[float, float, float]  # (theta, phi, radius)
    capabilities: List[str]
    neighbors: List[str]
    metadata: Dict


class TopologyManager:
    """
    ä¸‰å±‚çƒä½“æ‹“æ‰‘ç®¡ç†å™¨
    
    åŠŸèƒ½:
    - åŠ è½½æ‹“æ‰‘é…ç½®
    - æ„å»ºæ‹“æ‰‘å›¾ (NetworkX)
    - è·¯ç”±ç®—æ³• (æœ€çŸ­è·¯å¾„ã€è´Ÿè½½å‡è¡¡ã€åŸŸäº²å’Œ)
    - è´Ÿè½½ç›‘æ§
    """
    
    def __init__(self, topology_config_path: str):
        self.config_path = Path(topology_config_path)
        self.graph = nx.DiGraph()  # æœ‰å‘å›¾
        self.nodes: Dict[str, NodeInfo] = {}
        self.layers: Dict[str, List[str]] = {
            "core": [],
            "cognitive": [],
            "perception": []
        }
        self.domains: Dict[str, List[str]] = {}
        self.load_tracker: Dict[str, float] = {}  # èŠ‚ç‚¹è´Ÿè½½
        
        self._load_topology()
    
    def _load_topology(self):
        """åŠ è½½æ‹“æ‰‘é…ç½®"""
        logger.info(f"ğŸ“Š Loading topology from {self.config_path}")
        
        with open(self.config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        
        # åŠ è½½èŠ‚ç‚¹
        for node_data in config['nodes']:
            node = NodeInfo(
                node_id=node_data['id'],
                node_name=node_data['name'],
                layer=node_data['layer'],
                domain=node_data['domain'],
                coordinates=(
                    node_data['coordinates']['theta'],
                    node_data['coordinates']['phi'],
                    node_data['coordinates']['radius']
                ),
                capabilities=node_data.get('capabilities', []),
                neighbors=node_data.get('neighbors', []),
                metadata=node_data.get('metadata', {})
            )
            
            self.nodes[node.node_id] = node
            self.layers[node.layer].append(node.node_id)
            
            if node.domain not in self.domains:
                self.domains[node.domain] = []
            self.domains[node.domain].append(node.node_id)
            
            # æ·»åŠ åˆ°å›¾
            self.graph.add_node(
                node.node_id,
                layer=node.layer,
                domain=node.domain,
                coordinates=node.coordinates
            )
            
            # åˆå§‹åŒ–è´Ÿè½½
            self.load_tracker[node.node_id] = 0.0
        
        # æ·»åŠ è¾¹ (åŸºäºé‚»å±…å…³ç³»)
        for node_id, node in self.nodes.items():
            for neighbor_id in node.neighbors:
                if neighbor_id in self.nodes:
                    self.graph.add_edge(node_id, neighbor_id, weight=1.0)
        
        logger.info(f"âœ… Topology loaded: {len(self.nodes)} nodes, {len(self.graph.edges)} edges")
        logger.info(f"   Layers: {[(k, len(v)) for k, v in self.layers.items()]}")
        logger.info(f"   Domains: {[(k, len(v)) for k, v in self.domains.items()]}")
    
    def find_best_node(
        self,
        domain: Optional[str] = None,
        layer: Optional[str] = None,
        capabilities: Optional[List[str]] = None,
        source_node: Optional[str] = None,
        strategy: str = "load_balanced"
    ) -> Optional[str]:
        """
        æŸ¥æ‰¾æœ€ä½³èŠ‚ç‚¹
        
        Args:
            domain: ç›®æ ‡åŸŸ
            layer: ç›®æ ‡å±‚çº§
            capabilities: æ‰€éœ€èƒ½åŠ›
            source_node: æºèŠ‚ç‚¹ (ç”¨äºè·¯å¾„ä¼˜åŒ–)
            strategy: è·¯ç”±ç­–ç•¥
                - "load_balanced": è´Ÿè½½å‡è¡¡
                - "shortest_path": æœ€çŸ­è·¯å¾„
                - "domain_affinity": åŸŸäº²å’Œ
        
        Returns:
            æœ€ä½³èŠ‚ç‚¹ ID
        """
        # 1. ç­›é€‰å€™é€‰èŠ‚ç‚¹
        candidates = self._filter_candidates(domain, layer, capabilities)
        
        if not candidates:
            logger.warning(f"âš ï¸  No candidates found for domain={domain}, layer={layer}")
            return None
        
        # 2. æ ¹æ®ç­–ç•¥é€‰æ‹©
        if strategy == "load_balanced":
            return self._select_by_load(candidates)
        elif strategy == "shortest_path" and source_node:
            return self._select_by_path(candidates, source_node)
        elif strategy == "domain_affinity":
            return self._select_by_domain(candidates, domain)
        else:
            # é»˜è®¤: è´Ÿè½½å‡è¡¡
            return self._select_by_load(candidates)
    
    def _filter_candidates(
        self,
        domain: Optional[str],
        layer: Optional[str],
        capabilities: Optional[List[str]]
    ) -> List[str]:
        """ç­›é€‰å€™é€‰èŠ‚ç‚¹"""
        candidates = list(self.nodes.keys())
        
        # æŒ‰åŸŸç­›é€‰
        if domain and domain in self.domains:
            candidates = [n for n in candidates if n in self.domains[domain]]
        
        # æŒ‰å±‚çº§ç­›é€‰
        if layer and layer in self.layers:
            candidates = [n for n in candidates if n in self.layers[layer]]
        
        # æŒ‰èƒ½åŠ›ç­›é€‰
        if capabilities:
            candidates = [
                n for n in candidates
                if all(cap in self.nodes[n].capabilities for cap in capabilities)
            ]
        
        return candidates
    
    def _select_by_load(self, candidates: List[str]) -> str:
        """æŒ‰è´Ÿè½½é€‰æ‹©"""
        return min(candidates, key=lambda n: self.load_tracker.get(n, 0.0))
    
    def _select_by_path(self, candidates: List[str], source_node: str) -> str:
        """æŒ‰è·¯å¾„é•¿åº¦é€‰æ‹©"""
        if source_node not in self.graph:
            return self._select_by_load(candidates)
        
        # è®¡ç®—åˆ°æ¯ä¸ªå€™é€‰èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„
        paths = {}
        for candidate in candidates:
            try:
                path_length = nx.shortest_path_length(
                    self.graph, source_node, candidate
                )
                paths[candidate] = path_length
            except nx.NetworkXNoPath:
                paths[candidate] = float('inf')
        
        # é€‰æ‹©æœ€çŸ­è·¯å¾„
        return min(paths, key=paths.get)
    
    def _select_by_domain(self, candidates: List[str], domain: Optional[str]) -> str:
        """æŒ‰åŸŸäº²å’Œé€‰æ‹©"""
        if domain:
            # ä¼˜å…ˆé€‰æ‹©åŒåŸŸèŠ‚ç‚¹
            same_domain = [n for n in candidates if self.nodes[n].domain == domain]
            if same_domain:
                return self._select_by_load(same_domain)
        
        return self._select_by_load(candidates)
    
    def get_node_info(self, node_id: str) -> Optional[NodeInfo]:
        """è·å–èŠ‚ç‚¹ä¿¡æ¯"""
        return self.nodes.get(node_id)
    
    def get_layer_nodes(self, layer: str) -> List[str]:
        """è·å–æŒ‡å®šå±‚çº§çš„æ‰€æœ‰èŠ‚ç‚¹"""
        return self.layers.get(layer, [])
    
    def get_domain_nodes(self, domain: str) -> List[str]:
        """è·å–æŒ‡å®šåŸŸçš„æ‰€æœ‰èŠ‚ç‚¹"""
        return self.domains.get(domain, [])
    
    def update_load(self, node_id: str, load: float):
        """æ›´æ–°èŠ‚ç‚¹è´Ÿè½½"""
        if node_id in self.load_tracker:
            self.load_tracker[node_id] = load
    
    def get_topology_stats(self) -> Dict:
        """è·å–æ‹“æ‰‘ç»Ÿè®¡ä¿¡æ¯"""
        return {
            "total_nodes": len(self.nodes),
            "layers": {k: len(v) for k, v in self.layers.items()},
            "domains": {k: len(v) for k, v in self.domains.items()},
            "total_edges": len(self.graph.edges),
            "average_load": sum(self.load_tracker.values()) / len(self.load_tracker) if self.load_tracker else 0.0
        }
```

---

### 3. æ‹“æ‰‘æ„ŸçŸ¥çš„ ConstellationClient

#### 3.1 ç»§æ‰¿æ‰©å±•

```python
# åˆ›å»º fusion-experiment/ufo-galaxy-unified/fusion/topology_aware_client.py

import logging
from typing import Dict, List, Optional, Any

from microsoft-ufo.galaxy.client.constellation_client import ConstellationClient
from microsoft-ufo.galaxy.client.config_loader import ConstellationConfig
from microsoft-ufo.aip.messages import ClientMessage, ServerMessage

from .topology_manager import TopologyManager

logger = logging.getLogger(__name__)


class TopologyAwareConstellationClient(ConstellationClient):
    """
    æ‹“æ‰‘æ„ŸçŸ¥çš„ ConstellationClient
    
    æ‰©å±•å¾®è½¯çš„ ConstellationClientï¼Œæ·»åŠ :
    1. æ‹“æ‰‘ç®¡ç†
    2. æ‹“æ‰‘è·¯ç”±
    3. è´Ÿè½½å‡è¡¡
    """
    
    def __init__(
        self,
        config: Optional[ConstellationConfig] = None,
        task_name: Optional[str] = None,
        topology_config_path: Optional[str] = None,
        enable_topology: bool = True
    ):
        """
        åˆå§‹åŒ–æ‹“æ‰‘æ„ŸçŸ¥å®¢æˆ·ç«¯
        
        Args:
            config: Constellation é…ç½®
            task_name: ä»»åŠ¡åç§°
            topology_config_path: æ‹“æ‰‘é…ç½®æ–‡ä»¶è·¯å¾„
            enable_topology: æ˜¯å¦å¯ç”¨æ‹“æ‰‘åŠŸèƒ½
        """
        # è°ƒç”¨çˆ¶ç±»åˆå§‹åŒ–
        super().__init__(config, task_name)
        
        self.enable_topology = enable_topology
        self.topology_manager: Optional[TopologyManager] = None
        
        # å¦‚æœå¯ç”¨æ‹“æ‰‘ï¼ŒåŠ è½½æ‹“æ‰‘ç®¡ç†å™¨
        if enable_topology and topology_config_path:
            logger.info("ğŸŒ Initializing TopologyManager...")
            self.topology_manager = TopologyManager(topology_config_path)
            logger.info("âœ… TopologyManager initialized")
    
    async def assign_task_with_topology(
        self,
        task: Dict[str, Any],
        domain: Optional[str] = None,
        layer: Optional[str] = None,
        source_node: Optional[str] = None,
        strategy: str = "load_balanced"
    ) -> Optional[str]:
        """
        åŸºäºæ‹“æ‰‘åˆ†é…ä»»åŠ¡
        
        Args:
            task: ä»»åŠ¡æè¿°
            domain: ç›®æ ‡åŸŸ
            layer: ç›®æ ‡å±‚çº§
            source_node: æºèŠ‚ç‚¹
            strategy: è·¯ç”±ç­–ç•¥
        
        Returns:
            ç›®æ ‡èŠ‚ç‚¹ ID
        """
        if not self.enable_topology or not self.topology_manager:
            # å›é€€åˆ°æ ‡å‡†åˆ†é…
            logger.warning("âš ï¸  Topology not enabled, using standard assignment")
            return await self._standard_assign(task)
        
        # 1. ä»ä»»åŠ¡ä¸­æå–åŸŸå’Œå±‚çº§ (å¦‚æœæœªæŒ‡å®š)
        if not domain:
            domain = task.get('domain') or self._infer_domain(task)
        
        if not layer:
            layer = task.get('layer') or self._infer_layer(task)
        
        # 2. ä½¿ç”¨æ‹“æ‰‘ç®¡ç†å™¨æŸ¥æ‰¾æœ€ä½³èŠ‚ç‚¹
        target_node = self.topology_manager.find_best_node(
            domain=domain,
            layer=layer,
            capabilities=task.get('required_capabilities', []),
            source_node=source_node,
            strategy=strategy
        )
        
        if not target_node:
            logger.error(f"âŒ No suitable node found for task: {task}")
            return None
        
        logger.info(f"âœ… Task assigned to node: {target_node} (domain={domain}, layer={layer})")
        
        # 3. åˆ†é…ä»»åŠ¡åˆ°ç›®æ ‡èŠ‚ç‚¹
        return await self._send_task_to_node(target_node, task)
    
    def _infer_domain(self, task: Dict[str, Any]) -> str:
        """ä»ä»»åŠ¡æè¿°æ¨æ–­åŸŸ"""
        description = task.get('description', '').lower()
        
        # ç®€å•çš„å…³é”®è¯åŒ¹é…
        if any(kw in description for kw in ['image', 'vision', 'visual', 'see']):
            return 'vision'
        elif any(kw in description for kw in ['text', 'language', 'understand', 'nlu']):
            return 'nlu'
        elif any(kw in description for kw in ['state', 'manage', 'track']):
            return 'state_management'
        else:
            return 'general'
    
    def _infer_layer(self, task: Dict[str, Any]) -> str:
        """ä»ä»»åŠ¡æè¿°æ¨æ–­å±‚çº§"""
        description = task.get('description', '').lower()
        
        # ç®€å•çš„å±‚çº§æ¨æ–­
        if any(kw in description for kw in ['perceive', 'detect', 'capture']):
            return 'perception'
        elif any(kw in description for kw in ['analyze', 'understand', 'process']):
            return 'cognitive'
        elif any(kw in description for kw in ['coordinate', 'manage', 'control']):
            return 'core'
        else:
            return 'perception'  # é»˜è®¤ä»æ„ŸçŸ¥å±‚å¼€å§‹
    
    async def _standard_assign(self, task: Dict[str, Any]) -> Optional[str]:
        """æ ‡å‡†ä»»åŠ¡åˆ†é… (å›é€€æ–¹æ¡ˆ)"""
        # ä½¿ç”¨çˆ¶ç±»çš„è®¾å¤‡ç®¡ç†å™¨
        devices = self.device_manager.device_registry.get_all_devices()
        
        if not devices:
            logger.error("âŒ No devices available")
            return None
        
        # ç®€å•é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨è®¾å¤‡
        for device_id, device in devices.items():
            if device.status == "IDLE":
                return device_id
        
        # å¦‚æœæ²¡æœ‰ç©ºé—²è®¾å¤‡ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ª
        return list(devices.keys())[0] if devices else None
    
    async def _send_task_to_node(self, node_id: str, task: Dict[str, Any]) -> str:
        """å‘é€ä»»åŠ¡åˆ°æŒ‡å®šèŠ‚ç‚¹"""
        # è¿™é‡Œéœ€è¦è°ƒç”¨çˆ¶ç±»çš„è®¾å¤‡ç®¡ç†å™¨
        # å®é™…å®ç°éœ€è¦æ ¹æ®å¾®è½¯ UFO çš„ API
        
        logger.info(f"ğŸ“¤ Sending task to node {node_id}: {task.get('description', 'N/A')}")
        
        # TODO: å®ç°å®é™…çš„ä»»åŠ¡å‘é€é€»è¾‘
        # è¿™é‡Œéœ€è¦ä½¿ç”¨ device_manager å‘é€ä»»åŠ¡
        
        return node_id
    
    def get_topology_stats(self) -> Optional[Dict]:
        """è·å–æ‹“æ‰‘ç»Ÿè®¡ä¿¡æ¯"""
        if self.topology_manager:
            return self.topology_manager.get_topology_stats()
        return None
```

---

### 4. æ‰©å±• GalaxyClient

#### 4.1 é›†æˆæ‹“æ‰‘åŠŸèƒ½

```python
# ä¿®æ”¹ microsoft-ufo/galaxy/galaxy_client.py

# åœ¨æ–‡ä»¶é¡¶éƒ¨æ·»åŠ å¯¼å…¥
try:
    from fusion.topology_aware_client import TopologyAwareConstellationClient
    TOPOLOGY_AVAILABLE = True
except ImportError:
    TOPOLOGY_AVAILABLE = False
    logger.warning("âš ï¸  Topology fusion not available")


class GalaxyClient:
    def __init__(
        self,
        session_name: Optional[str] = None,
        task_name: Optional[str] = None,
        max_rounds: int = 10,
        log_level: str = "WARNING",
        output_dir: Optional[str] = None,
        # æ–°å¢å‚æ•°
        enable_topology: bool = False,
        topology_config: Optional[str] = None
    ):
        """
        Initialize Galaxy client.
        
        :param enable_topology: æ˜¯å¦å¯ç”¨æ‹“æ‰‘èåˆåŠŸèƒ½
        :param topology_config: æ‹“æ‰‘é…ç½®æ–‡ä»¶è·¯å¾„
        """
        # ... åŸæœ‰ä»£ç  ...
        
        self.enable_topology = enable_topology
        self.topology_config = topology_config
    
    async def initialize(self) -> None:
        """
        Initialize all Galaxy framework components.
        """
        try:
            with self.display.show_initialization_progress() as progress:
                task = progress.add_task(
                    "[cyan]Initializing UFO3 Framework...", total=None
                )
                
                self.logger.info("ğŸš€ Initializing UFO3 Framework components...")
                
                # Initialize constellation client
                progress.update(
                    task, description="[cyan]Setting up Constellation Client..."
                )
                
                # æ ¹æ®é…ç½®é€‰æ‹©å®¢æˆ·ç«¯ç±»å‹
                if self.enable_topology and TOPOLOGY_AVAILABLE and self.topology_config:
                    self.display.print_info("ğŸŒ Enabling topology fusion...")
                    self._client = TopologyAwareConstellationClient(
                        config=self._device_config,
                        task_name=self.task_name,
                        topology_config_path=self.topology_config,
                        enable_topology=True
                    )
                    self.display.print_success("âœ… TopologyAwareConstellationClient initialized")
                else:
                    self._client = ConstellationClient(
                        config=self._device_config,
                        task_name=self.task_name
                    )
                    self.display.print_success("âœ… ConstellationClient initialized")
                
                await self._client.initialize()
                
                # ... å…¶ä½™ä»£ç ä¿æŒä¸å˜ ...
```

---

### 5. èŠ‚ç‚¹é€‚é… AIP æ¥å£

#### 5.1 AIP é€‚é…å™¨åŸºç±»

```python
# åˆ›å»º fusion-experiment/ufo-galaxy-unified/fusion/node_adapter.py

import asyncio
import logging
from typing import Dict, Any, Optional, List
from abc import ABC, abstractmethod

# å¯¼å…¥å¾®è½¯çš„ AIP
import sys
sys.path.insert(0, '/home/ubuntu/fusion-experiment/ufo-galaxy-unified/microsoft-ufo')

from aip.endpoints.client_endpoint import DeviceClientEndpoint
from aip.messages import (
    ClientMessage, ServerMessage, Command, Result,
    ResultStatus, TaskStatus, ClientMessageType
)

logger = logging.getLogger(__name__)


class UFONodeAdapter(DeviceClientEndpoint, ABC):
    """
    UFO èŠ‚ç‚¹é€‚é…å™¨åŸºç±»
    
    å°†ä½ çš„èŠ‚ç‚¹é€‚é…ä¸ºå¾®è½¯ AIP çš„ Device Agent
    
    å­ç±»éœ€è¦å®ç°:
    - execute_command(): æ‰§è¡Œå…·ä½“å‘½ä»¤
    - get_capabilities(): è¿”å›èŠ‚ç‚¹èƒ½åŠ›
    """
    
    def __init__(
        self,
        node_id: str,
        node_name: str,
        layer: str,
        domain: str,
        server_url: str,
        node_api_url: str
    ):
        """
        åˆå§‹åŒ–èŠ‚ç‚¹é€‚é…å™¨
        
        Args:
            node_id: èŠ‚ç‚¹ ID (å¦‚ "Node_00")
            node_name: èŠ‚ç‚¹åç§° (å¦‚ "StateMachine")
            layer: å±‚çº§ ("core", "cognitive", "perception")
            domain: åŸŸ ("state_management", "vision", etc.)
            server_url: å¾®è½¯ Galaxy æœåŠ¡å™¨ URL
            node_api_url: èŠ‚ç‚¹çš„ FastAPI URL
        """
        # åˆå§‹åŒ– DeviceClientEndpoint
        super().__init__(
            device_id=node_id,
            server_url=server_url
        )
        
        self.node_id = node_id
        self.node_name = node_name
        self.layer = layer
        self.domain = domain
        self.node_api_url = node_api_url
        
        # HTTP å®¢æˆ·ç«¯ (ç”¨äºè°ƒç”¨èŠ‚ç‚¹çš„ FastAPI)
        import aiohttp
        self.http_session: Optional[aiohttp.ClientSession] = None
    
    async def start(self):
        """å¯åŠ¨é€‚é…å™¨"""
        import aiohttp
        self.http_session = aiohttp.ClientSession()
        
        # æ³¨å†Œåˆ°å¾®è½¯ Galaxy
        await self.connect()
        
        logger.info(f"âœ… Node adapter started: {self.node_id}")
    
    async def stop(self):
        """åœæ­¢é€‚é…å™¨"""
        if self.http_session:
            await self.http_session.close()
        
        await self.disconnect()
        
        logger.info(f"ğŸ›‘ Node adapter stopped: {self.node_id}")
    
    async def on_task_received(self, message: ServerMessage):
        """
        æ¥æ”¶ä»»åŠ¡ (æ¥è‡ªå¾®è½¯ Galaxy)
        
        è¿™æ˜¯ DeviceClientEndpoint çš„å›è°ƒ
        """
        logger.info(f"ğŸ“¥ Task received: {message.user_request}")
        
        try:
            # æ‰§è¡Œä»»åŠ¡
            result = await self.execute_task(message)
            
            # å‘é€ç»“æœ
            await self.send_task_result(result)
            
        except Exception as e:
            logger.error(f"âŒ Task execution failed: {e}")
            await self.send_error(str(e))
    
    async def execute_task(self, message: ServerMessage) -> Dict[str, Any]:
        """
        æ‰§è¡Œä»»åŠ¡
        
        å°†å¾®è½¯çš„ä»»åŠ¡è½¬æ¢ä¸ºèŠ‚ç‚¹ API è°ƒç”¨
        """
        # 1. æå–å‘½ä»¤
        commands = message.actions or []
        
        results = []
        for cmd in commands:
            result = await self.execute_command(cmd)
            results.append(result)
        
        return {
            "status": "completed",
            "results": results
        }
    
    @abstractmethod
    async def execute_command(self, command: Command) -> Result:
        """
        æ‰§è¡Œå•ä¸ªå‘½ä»¤
        
        å­ç±»å¿…é¡»å®ç°æ­¤æ–¹æ³•
        """
        pass
    
    async def call_node_api(
        self,
        endpoint: str,
        method: str = "POST",
        data: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        è°ƒç”¨èŠ‚ç‚¹çš„ FastAPI
        
        Args:
            endpoint: API ç«¯ç‚¹ (å¦‚ "/execute")
            method: HTTP æ–¹æ³•
            data: è¯·æ±‚æ•°æ®
        
        Returns:
            API å“åº”
        """
        url = f"{self.node_api_url}{endpoint}"
        
        try:
            if method == "POST":
                async with self.http_session.post(url, json=data) as resp:
                    return await resp.json()
            elif method == "GET":
                async with self.http_session.get(url) as resp:
                    return await resp.json()
            else:
                raise ValueError(f"Unsupported method: {method}")
        
        except Exception as e:
            logger.error(f"âŒ Node API call failed: {e}")
            raise
    
    @abstractmethod
    def get_capabilities(self) -> List[str]:
        """
        è¿”å›èŠ‚ç‚¹èƒ½åŠ›åˆ—è¡¨
        
        å­ç±»å¿…é¡»å®ç°æ­¤æ–¹æ³•
        """
        pass
    
    def get_metadata(self) -> Dict[str, Any]:
        """è¿”å›èŠ‚ç‚¹å…ƒæ•°æ®"""
        return {
            "node_id": self.node_id,
            "node_name": self.node_name,
            "layer": self.layer,
            "domain": self.domain,
            "capabilities": self.get_capabilities()
        }
```

#### 5.2 å…·ä½“èŠ‚ç‚¹é€‚é…å™¨ç¤ºä¾‹

```python
# åˆ›å»º fusion-experiment/ufo-galaxy-unified/fusion/adapters/node_00_adapter.py

from ..node_adapter import UFONodeAdapter
from aip.messages import Command, Result, ResultStatus


class Node00Adapter(UFONodeAdapter):
    """
    Node_00 (StateMachine) é€‚é…å™¨
    """
    
    def __init__(self, server_url: str):
        super().__init__(
            node_id="Node_00",
            node_name="StateMachine",
            layer="core",
            domain="state_management",
            server_url=server_url,
            node_api_url="http://localhost:8000"  # Node_00 çš„ FastAPI ç«¯å£
        )
    
    async def execute_command(self, command: Command) -> Result:
        """æ‰§è¡Œå‘½ä»¤"""
        tool_name = command.tool_name
        parameters = command.parameters or {}
        
        try:
            if tool_name == "acquire_lock":
                # è°ƒç”¨ Node_00 çš„é”æ¥å£
                response = await self.call_node_api(
                    "/lock/acquire",
                    method="POST",
                    data={
                        "node_id": parameters.get("node_id"),
                        "resource_id": parameters.get("resource_id"),
                        "timeout_seconds": parameters.get("timeout", 30)
                    }
                )
                
                return Result(
                    status=ResultStatus.SUCCESS if response["success"] else ResultStatus.FAILURE,
                    result=response,
                    namespace="state_management",
                    call_id=command.call_id
                )
            
            elif tool_name == "release_lock":
                response = await self.call_node_api(
                    "/lock/release",
                    method="POST",
                    data={
                        "node_id": parameters.get("node_id"),
                        "resource_id": parameters.get("resource_id"),
                        "token": parameters.get("token")
                    }
                )
                
                return Result(
                    status=ResultStatus.SUCCESS if response["success"] else ResultStatus.FAILURE,
                    result=response,
                    namespace="state_management",
                    call_id=command.call_id
                )
            
            else:
                return Result(
                    status=ResultStatus.FAILURE,
                    error=f"Unknown command: {tool_name}",
                    namespace="state_management",
                    call_id=command.call_id
                )
        
        except Exception as e:
            return Result(
                status=ResultStatus.FAILURE,
                error=str(e),
                namespace="state_management",
                call_id=command.call_id
            )
    
    def get_capabilities(self) -> List[str]:
        """è¿”å›èƒ½åŠ›"""
        return [
            "state_management",
            "lock_management",
            "node_registry",
            "global_state"
        ]
```

---

### 6. æ‹“æ‰‘é…ç½®æ–‡ä»¶

#### 6.1 åˆ›å»ºæ‹“æ‰‘é…ç½®

```json
// åˆ›å»º fusion-experiment/ufo-galaxy-unified/config/topology.json

{
  "version": "1.0",
  "topology_type": "three_layer_sphere",
  "layers": [
    {
      "name": "core",
      "index": 0,
      "radius": 1.0,
      "description": "æ ¸å¿ƒå±‚ - ç³»ç»Ÿç®¡ç†å’Œåè°ƒ"
    },
    {
      "name": "cognitive",
      "index": 1,
      "radius": 2.0,
      "description": "è®¤çŸ¥å±‚ - æ™ºèƒ½å¤„ç†å’Œåˆ†æ"
    },
    {
      "name": "perception",
      "index": 2,
      "radius": 3.0,
      "description": "æ„ŸçŸ¥å±‚ - æ•°æ®é‡‡é›†å’Œæ„ŸçŸ¥"
    }
  ],
  "domains": [
    "state_management",
    "vision",
    "nlu",
    "task_management",
    "security",
    "storage",
    "network",
    "sandbox",
    "general"
  ],
  "nodes": [
    {
      "id": "Node_00",
      "name": "StateMachine",
      "layer": "core",
      "domain": "state_management",
      "coordinates": {
        "theta": 0.0,
        "phi": 0.0,
        "radius": 1.0
      },
      "capabilities": [
        "state_management",
        "lock_management",
        "node_registry"
      ],
      "api_url": "http://localhost:8000",
      "neighbors": ["Node_04", "Node_02"],
      "metadata": {
        "priority": "critical",
        "max_load": 100
      }
    },
    {
      "id": "Node_04",
      "name": "Router",
      "layer": "core",
      "domain": "task_management",
      "coordinates": {
        "theta": 0.5,
        "phi": 1.57,
        "radius": 1.0
      },
      "capabilities": [
        "routing",
        "task_distribution"
      ],
      "api_url": "http://localhost:8004",
      "neighbors": ["Node_00", "Node_02", "Node_16"],
      "metadata": {
        "priority": "high",
        "max_load": 200
      }
    }
    // ... å…¶ä»– 101 ä¸ªèŠ‚ç‚¹ ...
  ]
}
```

---

### 7. ç»Ÿä¸€å¯åŠ¨è„šæœ¬

#### 7.1 èåˆç³»ç»Ÿå¯åŠ¨å™¨

```python
# åˆ›å»º fusion-experiment/ufo-galaxy-unified/fusion/start_fusion.py

#!/usr/bin/env python3
"""
UFO Galaxy æ·±åº¦èåˆç³»ç»Ÿå¯åŠ¨å™¨

å¯åŠ¨é¡ºåº:
1. å¯åŠ¨ä½ çš„ 103 ä¸ªèŠ‚ç‚¹ (Podman Compose)
2. å¯åŠ¨èŠ‚ç‚¹é€‚é…å™¨
3. å¯åŠ¨å¾®è½¯ UFOÂ³ Galaxy (å¸¦æ‹“æ‰‘æ”¯æŒ)
"""

import asyncio
import logging
import subprocess
import sys
import time
from pathlib import Path

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class FusionSystemStarter:
    """èåˆç³»ç»Ÿå¯åŠ¨å™¨"""
    
    def __init__(self):
        self.base_dir = Path(__file__).parent.parent
        self.nodes_started = False
        self.adapters_started = False
        self.galaxy_started = False
    
    async def start(self):
        """å¯åŠ¨èåˆç³»ç»Ÿ"""
        try:
            logger.info("ğŸš€ Starting UFO Galaxy Fusion System...")
            
            # 1. å¯åŠ¨èŠ‚ç‚¹ç³»ç»Ÿ
            await self.start_nodes()
            
            # 2. å¯åŠ¨é€‚é…å™¨
            await self.start_adapters()
            
            # 3. å¯åŠ¨å¾®è½¯ Galaxy
            await self.start_galaxy()
            
            logger.info("âœ… Fusion System started successfully!")
            logger.info("ğŸŒ Access Galaxy WebUI at: http://localhost:5000")
            
            # ä¿æŒè¿è¡Œ
            await self.keep_alive()
        
        except KeyboardInterrupt:
            logger.info("\nâš ï¸  Shutting down...")
            await self.shutdown()
        except Exception as e:
            logger.error(f"âŒ Startup failed: {e}")
            await self.shutdown()
            sys.exit(1)
    
    async def start_nodes(self):
        """å¯åŠ¨ 103 ä¸ªèŠ‚ç‚¹"""
        logger.info("ğŸ“¦ Starting 103 nodes with Podman Compose...")
        
        compose_file = self.base_dir / "podman-compose.yml"
        
        if not compose_file.exists():
            logger.warning("âš ï¸  podman-compose.yml not found, skipping...")
            return
        
        # ä½¿ç”¨ podman-compose å¯åŠ¨
        result = subprocess.run(
            ["podman-compose", "up", "-d"],
            cwd=self.base_dir,
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            raise RuntimeError(f"Failed to start nodes: {result.stderr}")
        
        logger.info("âœ… Nodes started, waiting for initialization...")
        await asyncio.sleep(10)  # ç­‰å¾…èŠ‚ç‚¹å¯åŠ¨
        
        self.nodes_started = True
    
    async def start_adapters(self):
        """å¯åŠ¨èŠ‚ç‚¹é€‚é…å™¨"""
        logger.info("ğŸ”Œ Starting node adapters...")
        
        # å¯¼å…¥é€‚é…å™¨
        from .adapters.node_00_adapter import Node00Adapter
        # ... å¯¼å…¥å…¶ä»–é€‚é…å™¨ ...
        
        # å¯åŠ¨é€‚é…å™¨
        galaxy_server_url = "ws://localhost:5000/constellation"
        
        adapters = [
            Node00Adapter(galaxy_server_url),
            # ... å…¶ä»–é€‚é…å™¨ ...
        ]
        
        for adapter in adapters:
            await adapter.start()
            logger.info(f"âœ… Adapter started: {adapter.node_id}")
        
        self.adapters_started = True
    
    async def start_galaxy(self):
        """å¯åŠ¨å¾®è½¯ Galaxy"""
        logger.info("ğŸŒŒ Starting Microsoft UFOÂ³ Galaxy...")
        
        # å¯¼å…¥ GalaxyClient
        sys.path.insert(0, str(self.base_dir / "microsoft-ufo"))
        from galaxy.galaxy_client import GalaxyClient
        
        # åˆ›å»ºå®¢æˆ·ç«¯ (å¯ç”¨æ‹“æ‰‘)
        client = GalaxyClient(
            session_name="fusion_session",
            enable_topology=True,
            topology_config=str(self.base_dir / "config" / "topology.json")
        )
        
        # åˆå§‹åŒ–
        await client.initialize()
        
        logger.info("âœ… Galaxy initialized with topology support")
        
        self.galaxy_started = True
        self.galaxy_client = client
    
    async def keep_alive(self):
        """ä¿æŒç³»ç»Ÿè¿è¡Œ"""
        logger.info("ğŸ”„ System running, press Ctrl+C to stop...")
        
        while True:
            await asyncio.sleep(60)
            
            # æ‰“å°çŠ¶æ€
            if hasattr(self, 'galaxy_client'):
                stats = self.galaxy_client._client.get_topology_stats()
                if stats:
                    logger.info(f"ğŸ“Š Topology stats: {stats}")
    
    async def shutdown(self):
        """å…³é—­ç³»ç»Ÿ"""
        logger.info("ğŸ›‘ Shutting down fusion system...")
        
        # åœæ­¢ Galaxy
        if self.galaxy_started:
            logger.info("Stopping Galaxy...")
            # TODO: åœæ­¢ Galaxy
        
        # åœæ­¢é€‚é…å™¨
        if self.adapters_started:
            logger.info("Stopping adapters...")
            # TODO: åœæ­¢é€‚é…å™¨
        
        # åœæ­¢èŠ‚ç‚¹
        if self.nodes_started:
            logger.info("Stopping nodes...")
            subprocess.run(
                ["podman-compose", "down"],
                cwd=self.base_dir
            )
        
        logger.info("âœ… Shutdown complete")


async def main():
    starter = FusionSystemStarter()
    await starter.start()


if __name__ == "__main__":
    asyncio.run(main())
```

---

## ğŸ“‹ å®æ–½æ­¥éª¤æ€»ç»“

### é˜¶æ®µ 1: åŸºç¡€æ¶æ„ (1 å‘¨)

**ä»»åŠ¡**:
1. âœ… åˆ›å»º `fusion/` ç›®å½•ç»“æ„
2. âœ… å®ç° TopologyManager
3. âœ… æ‰©å±• AIP åè®®æ¶ˆæ¯
4. âœ… åˆ›å»ºæ‹“æ‰‘é…ç½®æ–‡ä»¶

**éªŒè¯**:
- TopologyManager èƒ½åŠ è½½æ‹“æ‰‘
- è·¯ç”±ç®—æ³•æ­£å¸¸å·¥ä½œ

### é˜¶æ®µ 2: å®¢æˆ·ç«¯é›†æˆ (1 å‘¨)

**ä»»åŠ¡**:
1. âœ… å®ç° TopologyAwareConstellationClient
2. âœ… ä¿®æ”¹ GalaxyClient é›†æˆæ‹“æ‰‘
3. âœ… åˆ›å»ºèŠ‚ç‚¹é€‚é…å™¨åŸºç±»

**éªŒè¯**:
- GalaxyClient èƒ½å¯ç”¨æ‹“æ‰‘æ¨¡å¼
- æ‹“æ‰‘è·¯ç”±æ­£å¸¸å·¥ä½œ

### é˜¶æ®µ 3: èŠ‚ç‚¹é€‚é… (2 å‘¨)

**ä»»åŠ¡**:
1. âœ… ä¸ºæ ¸å¿ƒå±‚èŠ‚ç‚¹åˆ›å»ºé€‚é…å™¨ (16 ä¸ª)
2. âœ… ä¸ºè®¤çŸ¥å±‚èŠ‚ç‚¹åˆ›å»ºé€‚é…å™¨ (46 ä¸ª)
3. âœ… ä¸ºæ„ŸçŸ¥å±‚èŠ‚ç‚¹åˆ›å»ºé€‚é…å™¨ (31 ä¸ª)

**éªŒè¯**:
- æ¯ä¸ªèŠ‚ç‚¹èƒ½æ³¨å†Œåˆ° Galaxy
- èŠ‚ç‚¹èƒ½æ¥æ”¶å’Œæ‰§è¡Œä»»åŠ¡

### é˜¶æ®µ 4: æµ‹è¯•å’Œä¼˜åŒ– (1 å‘¨)

**ä»»åŠ¡**:
1. âœ… ç«¯åˆ°ç«¯æµ‹è¯•
2. âœ… æ€§èƒ½ä¼˜åŒ–
3. âœ… æ–‡æ¡£å®Œå–„

**éªŒè¯**:
- ç³»ç»Ÿç¨³å®šè¿è¡Œ
- æ€§èƒ½è¾¾æ ‡

### é˜¶æ®µ 5: å®¹å™¨åŒ–éƒ¨ç½² (1 å‘¨)

**ä»»åŠ¡**:
1. âœ… åˆ›å»º Podman Compose é…ç½®
2. âœ… åˆ›å»ºå¯åŠ¨è„šæœ¬
3. âœ… éƒ¨ç½²æµ‹è¯•

**éªŒè¯**:
- ä¸€é”®å¯åŠ¨
- å®¹å™¨åŒ–è¿è¡Œæ­£å¸¸

---

## â±ï¸ æ—¶é—´è§„åˆ’

| é˜¶æ®µ | ä»»åŠ¡ | æ—¶é—´ | ç´¯è®¡ |
|------|------|------|------|
| 1 | åŸºç¡€æ¶æ„ | 1 å‘¨ | 1 å‘¨ |
| 2 | å®¢æˆ·ç«¯é›†æˆ | 1 å‘¨ | 2 å‘¨ |
| 3 | èŠ‚ç‚¹é€‚é… | 2 å‘¨ | 4 å‘¨ |
| 4 | æµ‹è¯•ä¼˜åŒ– | 1 å‘¨ | 5 å‘¨ |
| 5 | å®¹å™¨åŒ–éƒ¨ç½² | 1 å‘¨ | 6 å‘¨ |

**æ€»è®¡**: 6 å‘¨ (çº¦ 1.5 ä¸ªæœˆ)

---

## ğŸ¯ ä¸‹ä¸€æ­¥

æˆ‘ç°åœ¨å¼€å§‹å®æ–½ï¼

**ä½ æƒ³è®©æˆ‘**:
1. âœ… ç«‹å³å¼€å§‹ç¼–å†™ä»£ç  (ä» TopologyManager å¼€å§‹)
2. â¸ï¸ å…ˆå›ç­”ä½ çš„é—®é¢˜
3. ğŸ“ å…ˆå®Œå–„æŸä¸ªéƒ¨åˆ†çš„è®¾è®¡

**è¯·å‘Šè¯‰æˆ‘ï¼** ğŸš€
